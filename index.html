<!DOCTYPE html>
<html lang="en"> 
<head>
    <meta charset="utf-8">
    <meta name="description" content="Munachiso Nwadike's research page">
    <meta name="author" content="Munachiso Nwadike">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300&display=swap" rel="stylesheet">
    <style>
        :root {
            --wide1: 710px;
            --wide2: 650px;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            font-size: 20px;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
        }

        a {
            color: inherit;
            text-decoration: none;
        } 

        .top-div,
        .bio-inner {
            width: var(--wide2);
            margin: 20px auto;
        }
        .bio-div {
              width: var(--wide1);
             margin: 20px auto;
             background-color: white;
             border-bottom: 3px solid black;
             text-align: justify;

            /* Subtle, one-sided shadow on the right */
         box-shadow: 4px 0 8px rgba(0, 0, 0, 0.1); /* Horizontal shadow */
         border-radius: 0; /* Solid corners */
         padding: 20px; /* Inner spacing */
        }

        .pic-div img {
            width: 100%;
            border: 3px solid black;
            box-sizing: border-box;
            display: block;
            margin: 23px auto;
        }
        .pic-div img.sam-img {
		    width: 70%;
		    margin: 23px auto;
		    display: block;
		}
        .personal-div {
            margin: 0 auto; 
            width: 100%; 
        }
        .mint-emoji {
          height: 1.6em;        /* match text size */
          width: auto;        /* keep aspect ratio */
          vertical-align: -0.48em; /* nudge to baseline; tweak as needed */
          margin-left: 0.2em; /* small gap from text */
        }
        .socials {
          height: 1.05em;        /* match text size */
          width: auto;        /* keep aspect ratio */
          vertical-align: -0.1em; /* nudge to baseline; tweak as needed */
          margin-left: 0.2em; /* small gap from text */
        }
        .scholar {
          height: 1.2em;        /* match text size */
          width: auto;        /* keep aspect ratio */
          vertical-align: -0.2em; /* nudge to baseline; tweak as needed */
          margin-left: 0.2em; /* small gap from text */
        }
        .rocket {
          height: 1.2em;        /* match text size */
          width: auto;        /* keep aspect ratio */
          vertical-align: -0.38em; /* nudge to baseline; tweak as needed */
          margin-left: 0.2em; /* small gap from text */
        }
        .ref-highlight {
    		    background: #add0d0ff;     /* soft green */
    		    padding: 0.05em 0.25em;
    		    border-radius: 3px;
    		}
    		/* Mobile zoom-out - transform method (better browser support) */
    		@media (max-width: 710px) {
    		    body {
    		        transform: scale(calc(100vw / 710px));
    		        transform-origin: top left;
    		        width: 710px;
    		        min-height: 100vh;
    		    }
    		}
        #life-canvas {
          width: 100%;
          height: 360px;          /* adjust as you like */
          display: block;
          border: 3px solid black;
          box-sizing: border-box;
          margin: 12px auto 0;
        }
    </style>
    <title>Munachiso Nwadike - Research Page</title>
</head>
<body>
    <div class="bio-div">
        <div class="top-div">
            <div class="pic-div">
                <img src="seaside.jpg" alt="Munachiso" class="sam-img">
            </div>
            <div class="personal-div">
                <p>
                    <b><a href="https://samunaai.github.io"><u>Sam</u></a></b><br>
                    Munachiso Samuel Nwadike (MSc, BSc@NYU)<br>
                    <a href="https://scholar.google.com/citations?user=wtjOZ9UAAAAJ&hl=en"><b>Google Scholar</b><img src="g_scholar.png" alt="gscholar" class="scholar"></a> • <a href="https://x.com/samunaai"><b>Twitter</b><img src="twitter_logo.png" alt="twitter" class="socials"></a><br>
                    <b>Currently:</b> Research Engineer (II) with Dr. Kentaro Inui <a href="https://scholar.google.com/citations?hl=en&user=38_o3-kAAAAJ&view_op=list_works&sortby=pubdate"><span class="ref-highlight">[<u>1</u>]</span></a><br>
                    <b>Lab:</b> <a href="https://www.mint-nlp-mbzuai.com/"><b>MINT Team<img src="mint.png" alt="MI" class="mint-emoji"></b></a> (Mechanistic Interpretability <a href="https://www.mint-nlp-mbzuai.com/publications"><span class="ref-highlight">[<u>2</u>]</span></a>) @ MBZUAI 
            </div>
        </div>
    </div>
    <div class="bio-div">
        <div class="bio-inner">
            <p><i>An Examination: "Why Small Teams Still Work Big Magic"</i> <a href="https://medium.com/@munachisonwadike/the-mythical-man-month-5a08324dd0e"><span class="ref-highlight">[<u>essay</u>]</span></a></p>
        </div>
    </div>
    <div class="bio-div">
        <div class="bio-inner">
            <p>Hi, I'm Sam, a researcher working on mechanistic interpretability of large language models (LLMs), the core technology behind AI systems like ChatGPT, Bard, Meta AI, and Grok.</p>
            <p>  I earned my bachelor’s degree at New York University (Abu Dhabi & New York). I am now at MBZUAI, an AI-focused research institute, with <b>highly-ranked</i></b> programs in both <a href="https://csrankings.org/#/index?nlp&world"><span class="ref-highlight">[<u>NLP</u>]</span></a> and <a href="https://csrankings.org/#/index?mlmining&world"><span class="ref-highlight">[<u>ML</u>]</span></a>.</p>
            <p>Let's catchup over email?</p>
            <p>E: munachisnwadike@gmail.com</p>
        </div>
    </div>
    <div class="bio-div">
      <div class="bio-inner">
        <p style="text-align:center; margin:0 0 6px 0; font-size:0.9em; opacity:0.75;"><i>Flow Field</i></p>
        <p style="text-align:center; margin:0 0 10px 0; font-size:0.82em; opacity:0.75;"><i>(Click and drag to stir)</i></p>
        <canvas id="life-canvas"></canvas>
      </div>
    </div>

<script>
(function () {
  const canvas = document.getElementById('life-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d', { alpha: false });

  // ====== Tunables (The logic you liked, strictly B&W) ======
  const cell = 24;              
  const arrowLen = 9;           
  const nParticlesBase = 1100;  
  const speed = 0.55;           
  const inertia = 0.94;         // High inertia for that "heavy drift" feel
  const trail = 0.08;           
  const damp = 0.97;            
  const injectStrength = 1.8;   
  const curl = 1.2;             
  const showArrows = false;      
  const arrowAlpha = 0.08;      // Faint black arrows
  // =========================================================

  let w = 0, h = 0, cols = 0, rows = 0;
  let fx, fy; 
  let particles = [];
  let pointerDown = false;
  let lastPt = null;

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;

    canvas.width = Math.max(1, Math.floor(cssW * dpr));
    canvas.height = Math.max(1, Math.floor(cssH * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    w = cssW; h = cssH;
    cols = Math.ceil(w / cell) + 1;
    rows = Math.ceil(h / cell) + 1;

    fx = new Float32Array(cols * rows);
    fy = new Float32Array(cols * rows);

    // Seed organic "Latent Space" flow
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const nx = x / cols;
        const ny = y / rows;
        let a = (Math.sin(nx * 4) * Math.cos(ny * 4));
        a += Math.sin(nx * 8 + ny * 5) * 0.5;
        const i = y * cols + x;
        fx[i] = Math.cos(a * Math.PI) * 0.2;
        fy[i] = Math.sin(a * Math.PI) * 0.2;
      }
    }

    const area = w * h;
    const nParticles = Math.max(400, Math.floor(nParticlesBase * (area / (700 * 360))));
    particles = new Array(nParticles).fill(0).map(() => ({
      x: Math.random() * w,
      y: Math.random() * h,
      vx: (Math.random() - 0.5) * 2,
      vy: (Math.random() - 0.5) * 2
    }));

    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);
  }

  // Smooth sub-grid sampling (Bilinear Interpolation)
  function sampleField(x, y) {
    const gx = (x / w) * (cols - 1);
    const gy = (y / h) * (rows - 1);
    const x0 = Math.floor(gx), y0 = Math.floor(gy);
    const x1 = Math.min(x0 + 1, cols - 1), y1 = Math.min(y0 + 1, rows - 1);
    const tx = gx - x0, ty = gy - y0;

    const i00 = y0 * cols + x0, i10 = y0 * cols + x1;
    const i01 = y1 * cols + x0, i11 = y1 * cols + x1;

    const vx = (fx[i00] * (1 - tx) + fx[i10] * tx) * (1 - ty) + (fx[i01] * (1 - tx) + fx[i11] * tx) * ty;
    const vy = (fy[i00] * (1 - tx) + fy[i10] * tx) * (1 - ty) + (fy[i01] * (1 - tx) + fy[i11] * tx) * ty;
    return [vx, vy];
  }

  function inject(x, y, dx, dy, strength) {
    const cx0 = (x / w) * cols, cy0 = (y / h) * rows;
    const r = 5.0; 
    const mag = Math.hypot(dx, dy) || 1;
    const ux = dx / mag, uy = dy / mag;

    for (let cy = Math.max(0, Math.floor(cy0 - r)); cy <= Math.min(rows - 1, Math.ceil(cy0 + r)); cy++) {
      for (let cx = Math.max(0, Math.floor(cx0 - r)); cx <= Math.min(cols - 1, Math.ceil(cx0 + r)); cx++) {
        const ox = cx - cx0, oy = cy - cy0;
        const d2 = ox * ox + oy * oy;
        if (d2 > r * r) continue;

        const fall = Math.exp(-d2 / (r * 1.5));
        const sign = (ux * oy - uy * ox) >= 0 ? 1 : -1;
        const i = cy * cols + cx;
        fx[i] += (-oy * sign * curl + ux * 1.5) * strength * fall * injectStrength * 0.1;
        fy[i] += (ox * sign * curl + uy * 1.5) * strength * fall * injectStrength * 0.1;
      }
    }
  }

  function stepParticles() {
    for (const p of particles) {
      const [fvX, fvY] = sampleField(p.x, p.y);

      p.vx = p.vx * inertia + fvX * (1 - inertia);
      p.vy = p.vy * inertia + fvY * (1 - inertia);

      const x0 = p.x, y0 = p.y;
      p.x += p.vx * speed * 15;
      p.y += p.vy * speed * 15;

      // WRAP FIX: Detect if we crossed the boundary
      let wrapped = false;
      if (p.x < 0) { p.x += w; wrapped = true; } 
      else if (p.x >= w) { p.x -= w; wrapped = true; }
      if (p.y < 0) { p.y += h; wrapped = true; } 
      else if (p.y >= h) { p.y -= h; wrapped = true; }

      // Only draw the line segment if the particle didn't wrap around
      if (!wrapped) {
        const speedMag = Math.hypot(p.vx, p.vy);
        const alpha = Math.min(0.05 + speedMag * 2, 0.4);
        ctx.strokeStyle = `rgba(0, 0, 0, ${alpha})`;
        ctx.lineWidth = 1.0;
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
      }
    }
  }

  function frame() {
    // Fill white with trail opacity
    ctx.fillStyle = `rgba(255, 255, 255, ${trail})`;
    ctx.fillRect(0, 0, w, h);

    // Decay field
    for (let i = 0; i < fx.length; i++) {
      fx[i] *= damp; fy[i] *= damp;
    }

    if (showArrows) {
      ctx.strokeStyle = `rgba(0, 0, 0, ${arrowAlpha})`;
      ctx.lineWidth = 0.7;
      for (let cy = 0; cy < rows; cy++) {
        for (let cx = 0; cx < cols; cx++) {
          const i = cy * cols + cx;
          const m = Math.hypot(fx[i], fy[i]);
          if (m < 0.01) continue;
          const x = (cx + 0.5) * cell, y = (cy + 0.5) * cell;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + (fx[i]/m) * arrowLen, y + (fy[i]/m) * arrowLen);
          ctx.stroke();
        }
      }
    }

    stepParticles();
    requestAnimationFrame(frame);
  }

  function getPoint(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * (w / rect.width),
      y: (e.clientY - rect.top) * (h / rect.height)
    };
  }

  canvas.addEventListener('pointerdown', (e) => {
    pointerDown = true;
    lastPt = getPoint(e);
    inject(lastPt.x, lastPt.y, (Math.random()-0.5)*10, (Math.random()-0.5)*10, 2.5);
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!pointerDown) return;
    const pt = getPoint(e);
    if (!lastPt) lastPt = pt;
    inject(pt.x, pt.y, pt.x - lastPt.x, pt.y - lastPt.y, 1.5);
    lastPt = pt;
  });

  window.addEventListener('pointerup', () => { pointerDown = false; lastPt = null; });
  window.addEventListener('resize', resize);
  
  canvas.style.touchAction = 'none';
  resize();
  requestAnimationFrame(frame);
})();
</script>


</body>
</html>


