<!DOCTYPE html>
<html lang="en"> 
<head>
    <meta charset="utf-8">
    <meta name="description" content="Munachiso Nwadike's research page">
    <meta name="author" content="Munachiso Nwadike">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300&display=swap" rel="stylesheet">
    <style>
        :root {
            --wide1: 710px;
            --wide2: 650px;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            font-size: 20px;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
        }

        a {
            color: inherit;
            text-decoration: none;
        } 

        .top-div,
        .bio-inner {
            width: var(--wide2);
            margin: 20px auto;
        }
        .bio-div {
              width: var(--wide1);
             margin: 20px auto;
             background-color: white;
             border-bottom: 3px solid black;
             text-align: justify;

            /* Subtle, one-sided shadow on the right */
         box-shadow: 4px 0 8px rgba(0, 0, 0, 0.1); /* Horizontal shadow */
         border-radius: 0; /* Solid corners */
         padding: 20px; /* Inner spacing */
        }

        .pic-div img {
            width: 100%;
            border: 3px solid black;
            box-sizing: border-box;
            display: block;
            margin: 23px auto;
        }
        .pic-div img.sam-img {
		    width: 70%;
		    margin: 23px auto;
		    display: block;
		}
        .personal-div {
            margin: 0 auto; 
            width: 100%; 
        }
        .mint-emoji {
          height: 1.6em;        /* match text size */
          width: auto;        /* keep aspect ratio */
          vertical-align: -0.48em; /* nudge to baseline; tweak as needed */
          margin-left: 0.2em; /* small gap from text */
        }
        .socials {
          height: 1.05em;        /* match text size */
          width: auto;        /* keep aspect ratio */
          vertical-align: -0.1em; /* nudge to baseline; tweak as needed */
          margin-left: 0.2em; /* small gap from text */
        }
        .scholar {
          height: 1.2em;        /* match text size */
          width: auto;        /* keep aspect ratio */
          vertical-align: -0.2em; /* nudge to baseline; tweak as needed */
          margin-left: 0.2em; /* small gap from text */
        }
        .rocket {
          height: 1.2em;        /* match text size */
          width: auto;        /* keep aspect ratio */
          vertical-align: -0.38em; /* nudge to baseline; tweak as needed */
          margin-left: 0.2em; /* small gap from text */
        }
        .ref-highlight {
    		    background: #add0d0ff;     /* soft green */
    		    padding: 0.05em 0.25em;
    		    border-radius: 3px;
    		}
    		/* Mobile zoom-out - transform method (better browser support) */
    		@media (max-width: 710px) {
    		    body {
    		        transform: scale(calc(100vw / 710px));
    		        transform-origin: top left;
    		        width: 710px;
    		        min-height: 100vh;
    		    }
    		}
        #life-canvas {
          width: 100%;
          height: 360px;          /* adjust as you like */
          display: block;
          border: 3px solid black;
          box-sizing: border-box;
          margin: 12px auto 0;
        }
    </style>
    <title>Munachiso Nwadike - Research Page</title>
</head>
<body>
    <div class="bio-div">
        <div class="top-div">
            <div class="pic-div">
                <img src="seaside.jpg" alt="Munachiso" class="sam-img">
            </div>
            <div class="personal-div">
                <p>
                    <b><a href="https://samunaai.github.io"><u>Sam</u></a></b><br>
                    Munachiso Samuel Nwadike (MSc, BSc@NYU)<br>
                    <a href="https://scholar.google.com/citations?user=wtjOZ9UAAAAJ&hl=en"><b>Google Scholar</b><img src="g_scholar.png" alt="gscholar" class="scholar"></a> • <a href="https://x.com/samunaai"><b>Twitter</b><img src="twitter_logo.png" alt="twitter" class="socials"></a><br>
                    <b>Currently:</b> Research Engineer (II) with Dr. Kentaro Inui <a href="https://scholar.google.com/citations?hl=en&user=38_o3-kAAAAJ&view_op=list_works&sortby=pubdate"><span class="ref-highlight">[<u>1</u>]</span></a><br>
                    <b>Lab:</b> <a href="https://www.mint-nlp-mbzuai.com/"><b>MINT Team<img src="mint.png" alt="MI" class="mint-emoji"></b></a> (Mechanistic Interpretability <a href="https://www.mint-nlp-mbzuai.com/publications"><span class="ref-highlight">[<u>2</u>]</span></a>) @ MBZUAI 
            </div>
        </div>
    </div>
    <div class="bio-div">
        <div class="bio-inner">
            <p><i>An Examination: "Why Small Teams Still Work Big Magic"</i> <a href="https://medium.com/@munachisonwadike/the-mythical-man-month-5a08324dd0e"><span class="ref-highlight">[<u>essay</u>]</span></a></p>
        </div>
    </div>
    <div class="bio-div">
        <div class="bio-inner">
            <p>Hi, I'm Sam, a researcher working on mechanistic interpretability of large language models (LLMs), the core technology behind AI systems like ChatGPT, Bard, Meta AI, and Grok.</p>
            <p>  I earned my bachelor’s degree at New York University (Abu Dhabi & New York). I am now at MBZUAI, an AI-focused research institute, with <b>highly-ranked</i></b> programs in both <a href="https://csrankings.org/#/index?nlp&world"><span class="ref-highlight">[<u>NLP</u>]</span></a> and <a href="https://csrankings.org/#/index?mlmining&world"><span class="ref-highlight">[<u>ML</u>]</span></a>.</p>
            <p>Let's catchup over email?</p>
            <p>E: munachisnwadike@gmail.com</p>
        </div>
    </div>
    <div class="bio-div">
      <div class="bio-inner">
        <p style="text-align:center; margin:0 0 6px 0;"><b>Flow Field</b></p>
        <p style="text-align:center; margin:0 0 10px 0; font-size:0.82em; opacity:0.75;"><i>Click and drag to stir the field.</i></p>
        <canvas id="life-canvas"></canvas>
      </div>
    </div>

<script>
(function () {
  const canvas = document.getElementById('life-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d', { alpha: false });

  // ====== Tunables ======
  const cell = 26;              // grid spacing for arrows/field
  const arrowLen = 10;          // arrow length in px
  const nParticlesBase = 900;   // will scale with canvas area
  const speed = 0.85;           // particle step size
  const trail = 0.10;           // 0..1 (lower = longer trails)
  const damp = 0.965;           // field decay per frame (closer to 1 = longer lasting)
  const injectStrength = 1.35;  // how strong drag/click affects field
  const curl = 1.0;             // swirl amount injected
  const showArrows = true;      // set false if you only want particles
  const arrowAlpha = 0.40;      // arrow opacity
  // ======================

  let w = 0, h = 0, cols = 0, rows = 0;
  let fx, fy;                   // field vectors
  let particles = [];
  let pointerDown = false;
  let lastPt = null;

  function resize() {
    const dpr = window.devicePixelRatio || 1;
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;

    canvas.width = Math.max(1, Math.floor(cssW * dpr));
    canvas.height = Math.max(1, Math.floor(cssH * dpr));
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    w = cssW; h = cssH;
    cols = Math.max(1, Math.floor(w / cell));
    rows = Math.max(1, Math.floor(h / cell));

    fx = new Float32Array(cols * rows);
    fy = new Float32Array(cols * rows);

    // Seed a gentle base flow so it is not static before interaction
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const nx = x / cols;
        const ny = y / rows;
        const a = (Math.sin(nx * 6.0) + Math.cos(ny * 6.0)) * 0.7;
        const i = y * cols + x;
        fx[i] = Math.cos(a) * 0.35;
        fy[i] = Math.sin(a) * 0.35;
      }
    }

    const area = w * h;
    const nParticles = Math.max(300, Math.floor(nParticlesBase * (area / (700 * 360))));
    particles = new Array(nParticles).fill(0).map(() => ({
      x: Math.random() * w,
      y: Math.random() * h,
      vx: 0,
      vy: 0
    }));

    // Clear
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);
  }

  function idx(cx, cy) { return cy * cols + cx; }

  function sampleField(x, y) {
    const cx = Math.max(0, Math.min(cols - 1, (x / w) * cols | 0));
    const cy = Math.max(0, Math.min(rows - 1, (y / h) * rows | 0));
    const i = idx(cx, cy);
    return [fx[i], fy[i]];
  }

  function decayField() {
    for (let i = 0; i < fx.length; i++) {
      fx[i] *= damp;
      fy[i] *= damp;
    }
  }

  // Inject a swirl centered at (x,y). Drag direction influences rotation.
  function inject(x, y, dx, dy, strength) {
    const cx0 = (x / w) * cols;
    const cy0 = (y / h) * rows;

    // radius in grid cells
    const r = 4.2;

    // direction for swirl: based on drag vector; if tiny, default
    const mag = Math.hypot(dx, dy) || 1;
    const ux = dx / mag;
    const uy = dy / mag;

    const minX = Math.max(0, Math.floor(cx0 - r));
    const maxX = Math.min(cols - 1, Math.ceil(cx0 + r));
    const minY = Math.max(0, Math.floor(cy0 - r));
    const maxY = Math.min(rows - 1, Math.ceil(cy0 + r));

    for (let cy = minY; cy <= maxY; cy++) {
      for (let cx = minX; cx <= maxX; cx++) {
        const ox = cx - cx0;
        const oy = cy - cy0;
        const d2 = ox * ox + oy * oy;
        if (d2 > r * r) continue;

        // falloff
        const fall = Math.exp(-d2 / (r * r));

        // swirl vector (perpendicular to radial)
        // Use drag direction to bias curl direction.
        // Perp radial: (-oy, ox). Multiply by sign from drag orientation.
        const sign = (ux * oy - uy * ox) >= 0 ? 1 : -1;
        const sx = -oy * sign;
        const sy =  ox * sign;

        const i = idx(cx, cy);

        fx[i] += (sx * curl + ux * 1.1) * strength * fall * injectStrength;
        fy[i] += (sy * curl + uy * 1.1) * strength * fall * injectStrength;
      }
    }
  }

  function drawArrow(x, y, vx, vy) {
    const m = Math.hypot(vx, vy);
    if (m < 0.0001) return;

    const ux = vx / m;
    const uy = vy / m;

    const x2 = x + ux * arrowLen;
    const y2 = y + uy * arrowLen;

    // arrow head
    const hx = -uy;
    const hy =  ux;

    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x2 - ux * 3 - hx * 3, y2 - uy * 3 - hy * 3);
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - ux * 3 + hx * 3, y2 - uy * 3 + hy * 3);
    ctx.stroke();
  }

  function renderArrows() {
    ctx.strokeStyle = `rgba(17,17,17,${arrowAlpha})`;
    ctx.lineWidth = 1;

    for (let cy = 0; cy < rows; cy++) {
      for (let cx = 0; cx < cols; cx++) {
        const i = idx(cx, cy);
        const x = (cx + 0.5) * cell;
        const y = (cy + 0.5) * cell;
        drawArrow(x, y, fx[i], fy[i]);
      }
    }
  }

  function stepParticles() {
    ctx.strokeStyle = 'rgba(17,17,17,0.35)';
    ctx.lineWidth = 1;

    for (const p of particles) {
      const [vx, vy] = sampleField(p.x, p.y);

      const x0 = p.x, y0 = p.y;

      // follow field with smoothing
      p.vx = 0.80 * p.vx + 0.20 * vx;
      p.vy = 0.80 * p.vy + 0.20 * vy;

      p.x += p.vx * speed;
      p.y += p.vy * speed;

      // wrap
      if (p.x < 0) p.x += w;
      if (p.x >= w) p.x -= w;
      if (p.y < 0) p.y += h;
      if (p.y >= h) p.y -= h;

      ctx.beginPath();
      ctx.moveTo(x0, y0);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
    }
  }

  function fade() {
    ctx.fillStyle = `rgba(255,255,255,${trail})`;
    ctx.fillRect(0, 0, w, h);
  }

  function frame() {
    fade();
    decayField();
    if (showArrows) renderArrows();
    stepParticles();
    requestAnimationFrame(frame);
  }

  function getPoint(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (canvas.clientWidth / rect.width);
    const y = (e.clientY - rect.top) * (canvas.clientHeight / rect.height);
    return { x, y };
  }

  function onDown(e) {
    pointerDown = true;
    const pt = getPoint(e);
    lastPt = pt;

    // click/tap pulse
    inject(pt.x, pt.y, 1, 0, 0.9);
  }

  function onMove(e) {
    if (!pointerDown) return;
    const pt = getPoint(e);
    if (!lastPt) lastPt = pt;

    const dx = pt.x - lastPt.x;
    const dy = pt.y - lastPt.y;

    // stronger while dragging
    inject(pt.x, pt.y, dx, dy, 1.2);

    lastPt = pt;
  }

  function onUp() {
    pointerDown = false;
    lastPt = null;
  }

  // Pointer events (works for mouse + touch)
  canvas.style.touchAction = 'none';
  canvas.addEventListener('pointerdown', onDown);
  canvas.addEventListener('pointermove', onMove);
  window.addEventListener('pointerup', onUp);
  window.addEventListener('pointercancel', onUp);

  // optional: double click to reset
  canvas.addEventListener('dblclick', function () { resize(); });

  resize();
  window.addEventListener('resize', resize);
  requestAnimationFrame(frame);
})();
</script>


</body>
</html>


