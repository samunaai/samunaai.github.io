<!DOCTYPE html>
<html lang="en"> 
<head>
    <meta charset="utf-8">
    <meta name="description" content="Munachiso Nwadike's research page">
    <meta name="author" content="Munachiso Nwadike">
    
    <!-- FIX 1: This one line replaces the "transform" CSS and the "syncHeight" JS -->
    <meta name="viewport" content="width=710">

    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300&display=swap" rel="stylesheet">
    <style>
        :root {
            --wide1: 710px;
            --wide2: 650px;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            font-size: 20px;
            margin: 0;
            padding: 0;
            background-color: #f9f9f9;
            width: 710px; /* Force consistent width */
            margin-left: auto;
            margin-right: auto;
            overflow-x: hidden;
        }

        a { color: inherit; text-decoration: none; } 

        .top-div, .bio-inner {
            width: var(--wide2);
            margin: 20px auto;
        }

        .bio-div {
             width: var(--wide1);
             margin: 20px auto;
             background-color: white;
             border-bottom: 3px solid black;
             text-align: justify;
             box-shadow: 4px 0 8px rgba(0, 0, 0, 0.1);
             padding: 20px;
             box-sizing: border-box;
        }

        .pic-div img {
            width: 100%;
            border: 3px solid black;
            box-sizing: border-box;
            display: block;
            margin: 23px auto;
        }
        .pic-div img.sam-img { width: 70%; margin: 23px auto; display: block; }
        .personal-div { margin: 0 auto; width: 100%; }
        
        .mint-emoji { height: 1.6em; width: auto; vertical-align: -0.48em; margin-left: 0.2em; }
        .socials { height: 1.05em; width: auto; vertical-align: -0.1em; margin-left: 0.2em; }
        .scholar { height: 1.2em; width: auto; vertical-align: -0.2em; margin-left: 0.2em; }
        .ref-highlight { background: #add0d0ff; padding: 0.05em 0.25em; border-radius: 3px; }

        #life-canvas {
          width: 100%;
          height: 360px;
          display: block;
          border: 3px solid black;
          box-sizing: border-box;
          margin: 12px auto 0;
          cursor: default;
        }
    </style>
    <title>Munachiso Nwadike - Research Page</title>
</head>
<body>
    <!-- No need for <div id="page"> anymore -->
    <div class="bio-div">
        <div class="top-div">
            <div class="pic-div">
                <img src="seaside.jpg" alt="Munachiso" class="sam-img">
            </div>
            <div class="personal-div">
                <p>
                    <b><a href="https://samunaai.github.io"><u>Sam</u></a></b><br>
                    Munachiso Samuel Nwadike (MSc, BSc@NYU)<br>
                    <a href="https://scholar.google.com/citations?user=wtjOZ9UAAAAJ&hl=en"><b>Google Scholar</b><img src="g_scholar.png" alt="gscholar" class="scholar"></a> • <a href="https://x.com/samunaai"><b>Twitter</b><img src="twitter_logo.png" alt="twitter" class="socials"></a><br>
                    <b>Currently:</b> Research Engineer (II) with Dr. Kentaro Inui <a href="https://scholar.google.com/citations?hl=en&user=38_o3-kAAAAJ&view_op=list_works&sortby=pubdate"><span class="ref-highlight">[<u>1</u>]</span></a><br>
                    <b>Lab:</b> <a href="https://www.mint-nlp-mbzuai.com/"><b>MINT Team<img src="mint.png" alt="MI" class="mint-emoji"></b></a> (Mechanistic Interpretability <a href="https://www.mint-nlp-mbzuai.com/publications"><span class="ref-highlight">[<u>2</u>]</span></a>) @ MBZUAI 
                </p>
            </div>
        </div>
    </div>

    <div class="bio-div">
        <div class="bio-inner">
            <p><i>An Examination: "Why Small Teams Still Work Big Magic"</i> <a href="https://medium.com/@munachisonwadike/the-mythical-man-month-5a08324dd0e"><span class="ref-highlight">[<u>essay</u>]</span></a></p>
        </div>
    </div>

    <div class="bio-div">
        <div class="bio-inner">
            <p>Hi, I'm Sam, a researcher working on mechanistic interpretability of large language models (LLMs), the core technology behind AI systems like ChatGPT, Bard, Meta AI, and Grok.</p>
            <p>I earned my bachelor’s degree at New York University (Abu Dhabi & New York). I am now at MBZUAI, an AI-focused research institute, with <b>highly-ranked</b> programs in both <a href="https://csrankings.org/#/index?nlp&world"><span class="ref-highlight">[<u>NLP</u>]</span></a> and <a href="https://csrankings.org/#/index?mlmining&world"><span class="ref-highlight">[<u>ML</u>]</span></a>.</p>
            <p>Let's catchup over email?</p>
            <p>E: munachisnwadike@gmail.com</p>
        </div>
    </div>

    <div class="bio-div">
      <div class="bio-inner">
        <p style="text-align:center; margin:0 0 6px 0; font-size:0.9em; opacity:0.75;">Appendix: Clickable Word Cloud</p>
        <canvas id="life-canvas"></canvas>
      </div>
    </div>

<script>
(function () {
  const canvas = document.getElementById('life-canvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d', { alpha: false });

  const concepts = [
    "Causal Cycles", "Chain-of-Thought", "Reasoning", "Residual Stream", "Attention Heads", "Transformers", "Logit Lens", "SAEs", 
    "Circuits", "Features", "Monosemantic", "Polysemantics", "PCA", "Kernel Alignment",  
    "Internal Activations", "Ablation", "Induction Heads", "Grokking", "Phase Change",
    "Steering", "Probing", "Causal Patching",
    "MLP", "Dictionary Learning", "Tokens"
  ];

  let w, h, words = [];
  let mouse = { x: -1000, y: -1000 };

  function init() {
    const dpr = window.devicePixelRatio || 1;
    w = canvas.clientWidth;
    h = canvas.clientHeight;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    words = [];
    
    // GRID SETTINGS
    const cols = 4; // Using 4 columns gives long words like "Dictionary Learning" more space
    const totalWords = concepts.length;
    const rows = Math.ceil(totalWords / cols);
    
    const cellW = w / cols;
    const cellH = h / rows;

    concepts.forEach((text, i) => {
      const col = i % cols;
      const row = Math.floor(i / cols);
      
      // Calculate how many words are in this specific row (to center the last row)
      const isLastRow = row === rows - 1;
      const wordsInThisRow = isLastRow ? (totalWords % cols || cols) : cols;
      
      // Horizontal centering offset for the last row
      const xRowOffset = isLastRow ? (w - (wordsInThisRow * cellW)) / 2 : 0;

      // Base positions
      const baseX = xRowOffset + (col * cellW) + (cellW / 2);
      const baseY = (row * cellH) + (cellH / 2);

      words.push({
        text: text,
        // Small jitter (15% of cell size) keeps it organic but prevents clumping
        bx: baseX + (Math.random() - 0.5) * (cellW * 0.3),
        by: baseY + (Math.random() - 0.5) * (cellH * 0.3),
        x: 0, y: 0,
        size: 15,
        scale: 1,
        opacity: 0.28,
        radius: 45 // Clickable area
      });
    });
  }

  function frame() {
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, w, h);

    const activeRadius = 140; 
    let hoveredAny = false;

    words.forEach(p => {
      const dx = mouse.x - p.bx;
      const dy = mouse.y - p.by;
      const dist = Math.hypot(dx, dy);

      if (dist < activeRadius) {
        const proximity = 1 - (dist / activeRadius);
        p.scale += ((1 + proximity * 1.1) - p.scale) * 0.15;
        p.opacity += ((0.35 + proximity * 0.65) - p.opacity) * 0.15;
        p.x += ((p.bx - dx * 0.12 * proximity) - p.x) * 0.15;
        p.y += ((p.by - dy * 0.12 * proximity) - p.y) * 0.15;
        
        if (dist < 40) hoveredAny = true;
      } else {
        p.scale += (1 - p.scale) * 0.08;
        p.opacity += (0.28 - p.opacity) * 0.08;
        p.x += (p.bx - p.x) * 0.08;
        p.y += (p.by - p.y) * 0.08;
      }

      ctx.font = `500 ${p.size * p.scale}px 'Montserrat'`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = `rgba(0, 0, 0, ${p.opacity})`;
      ctx.fillText(p.text, p.x, p.y);
    });

    canvas.style.cursor = hoveredAny ? 'pointer' : 'default';
    requestAnimationFrame(frame);
  }

  function getPoint(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: (e.clientX - rect.left) * (w / rect.width),
      y: (e.clientY - rect.top) * (h / rect.height)
    };
  }

  canvas.addEventListener('pointermove', (e) => {
    const pt = getPoint(e);
    mouse.x = pt.x;
    mouse.y = pt.y;
  });

  canvas.addEventListener('pointerdown', (e) => {
    const pt = getPoint(e);
    words.forEach(p => {
      // Check distance from current animated position for better feel
      const dist = Math.hypot(pt.x - p.x, pt.y - p.y);
      if (dist < p.radius) { 
        const query = encodeURIComponent(p.text + " mechanistic interpretability");
        window.open(`https://scholar.google.com/scholar?q=${query}`, '_blank');
      }
    });
  });

  canvas.addEventListener('pointerleave', () => {
    mouse.x = -1000; mouse.y = -1000;
  });

  window.addEventListener('resize', init);
  canvas.style.touchAction = 'none';

  init();
  frame();
})();
</script>
</body>
</html>
